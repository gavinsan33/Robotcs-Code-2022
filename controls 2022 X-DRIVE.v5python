{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nmotorTL = Motor(Ports.PORT20, GearSetting.RATIO_6_1, False)\nmotorTR = Motor(Ports.PORT11, GearSetting.RATIO_6_1, True)\nmotorBL = Motor(Ports.PORT10, GearSetting.RATIO_6_1, False)\nmotorBR = Motor(Ports.PORT1, GearSetting.RATIO_6_1, True)\nm5 = Motor(Ports.PORT3, GearSetting.RATIO_6_1, False)\nm6 = Motor(Ports.PORT6, GearSetting.RATIO_6_1, False)\nm7 = Motor(Ports.PORT7, GearSetting.RATIO_6_1, False)\nm8 = Motor(Ports.PORT8, GearSetting.RATIO_6_1, False)\ncontroller_1 = Controller(PRIMARY)\nsol_a = DigitalOut(brain.three_wire_port.a)\nsols = DigitalOut(brain.three_wire_port.b)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      Control and Record 2022\n#\tAuthor:       Gavin Sanders\n#\tCreated:      October 2022\n#\tDescription:  Stores and replays controller input\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\n\n#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\n# Library imports\nfrom vex import *\nimport math\n\n# Begin project code\n\n\nleftSpeed, rightSpeed = 0, 0\nprevLeftState, prevRightState = 1, 1\nlHorizAxisState, rHorizAxisState = 0, 0\nprevLHorizAxisState, prevRHorizAxisState = 1, 1\n\nbutton_states = [False for i in range(12)]\nprev_button_states = [False for i in range(12)]\n\nrecordInput = False\n\nautonomous_start_offset = 0\nfirst_record = True\n\n#Paste recorded input here:\nRECORDED_INPUT = \"0&1&0&0&000000000000@0|0&2&0&0&000000000000@43|0&1&0&0&000000000000@64|0&2&0&0&000000000000@107|0&3&0&0&000000000000@149|0&4&0&0&000000000000@170|0&6&0&0&000000000000@192|0&7&0&0&000000000000@276|0&8&0&0&000000000000@383|0&9&0&0&000000000000@446|0&8&0&0&000000000000@510|0&10&0&0&000000000000@531|0&13&0&0&000000000000@552|0&14&0&0&000000000000@574|0&17&0&0&000000000000@680|0&15&0&0&000000000000@744|1&17&0&0&000000000000@765|0&17&0&0&000000000000@807|1&15&0&0&000000000000@828|1&17&0&0&000000000000@850|1&18&0&0&000000000000@892|0&17&0&0&000000000000@935|1&17&0&0&000000000000@977|0&15&0&0&000000000000@1041|0&17&0&0&000000000000@1062|1&17&0&0&000000000000@1083|1&18&0&0&000000000000@1147|1&15&0&0&000000000000@1189|1&18&0&0&000000000000@1211|1&17&0&0&000000000000@1232|1&15&0&0&000000000000@1274|2&17&0&0&000000000000@1317|1&17&0&0&000000000000@1338|2&17&0&0&000000000000@1359|3&15&0&0&000000000000@1381|5&15&0&0&000000000000@1402|7&17&0&0&000000000000@1423|8&15&0&0&000000000000@1444|9&15&0&0&000000000000@1529|10&15&0&0&000000000000@1572|11&15&0&0&000000000000@1593|12&14&0&0&000000000000@1614|13&15&0&0&000000000000@1636|14&15&0&0&000000000000@1657|14&14&0&0&000000000000@1699|14&15&0&0&000000000000@1721|14&14&0&0&000000000000@1763|14&15&0&0&000000000000@1805|14&14&0&0&000000000000@1827|14&15&0&0&000000000000@1848|14&14&0&0&000000000000@2039|14&15&0&0&000000000000@2060|14&14&0&0&000000000000@2103|14&15&0&0&000000000000@2124|14&17&0&0&000000000000@2251|14&15&0&0&000000000000@2273|14&17&0&0&000000000000@2336|14&15&0&0&000000000000@2421|14&17&0&0&000000000000@2464|14&15&0&0&000000000000@2527|14&17&0&0&000000000000@2549|14&15&0&0&000000000000@2633|14&17&0&0&000000000000@2782|14&15&0&0&000000000000@2909|14&17&0&0&000000000000@2931|14&15&0&0&000000000000@2952|14&17&0&0&000000000000@2973|14&15&0&0&000000000000@3122|14&17&0&0&000000000000@3164|14&15&0&0&000000000000@3185|14&17&0&0&000000000000@3291|14&15&0&0&000000000000@3376|14&17&0&0&000000000000@3398|14&15&0&0&000000000000@3419|0&0&0&0&000000000000@3461|\"\n##############\n\nm5.set_stopping(HOLD)\nm6.set_stopping(HOLD)\nm7.set_stopping(HOLD)\nm8.set_stopping(HOLD)\n\ndef move(leftUp, rightUp, leftHoriz, rightHoriz):\n    global button_states\n\n    motors = (motorTL, motorTR, motorBL, motorBR)\n    direction = lambda x : FORWARD if x > 0 else REVERSE\n    \n    if(leftUp > 0 and leftHoriz > 0):\n        #Quadrant 1\n\n        if(rightHoriz == 0):\n            #Move Northeast\n            vert_percent = leftUp / float(leftUp + abs(leftHoriz))\n            l_horiz_percent = 1.0 - vert_percent\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n\n        elif(rightHoriz > 0):\n            #Turn right (+-+-) while going Northeast\n            vert_percent = leftUp / float(leftUp + leftHoriz + rightHoriz)\n            l_horiz_percent = leftHoriz / float(leftUp + leftHoriz + rightHoriz)\n            r_horiz_percent = rightHoriz / float(leftUp + leftHoriz + rightHoriz)\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        else:\n            #Turn left (-+-+) while going Northeast\n            vert_percent = leftUp / float(leftUp + leftHoriz + abs(rightHoriz))\n            l_horiz_percent = leftHoriz / float(leftUp + leftHoriz + abs(rightHoriz))\n            r_horiz_percent = abs(rightHoriz) / float(leftUp + leftHoriz + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n        \n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp > 0 and leftHoriz < 0):\n        #Quadrant 2\n    \n        if(rightHoriz == 0): \n            #Move Northwest\n            vert_percent = leftUp / float(leftUp + abs(leftHoriz))\n            horiz_percent = 1.0 - vert_percent\n\n            m1_weight = int((vert_percent * leftUp) + (horiz_percent * leftHoriz))\n            m2_weight = int((vert_percent * leftUp) + (horiz_percent * abs(leftHoriz)))\n            m3_weight = int((vert_percent * leftUp) + (horiz_percent * abs(leftHoriz)))\n            m4_weight = int((vert_percent * leftUp) + (horiz_percent * leftHoriz))\n\n        elif(rightHoriz > 0):\n            #Turn right (+-+-) while going Northwest\n            vert_percent = leftUp / float(leftUp + abs(leftHoriz) + rightHoriz)\n            l_horiz_percent = abs(leftHoriz) / float(leftUp + abs(leftHoriz) + rightHoriz)\n            r_horiz_percent = rightHoriz / float(leftUp + abs(leftHoriz) + rightHoriz)\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        else:\n            #Turn left (-+-+) while going Northwest\n            vert_percent = leftUp / float(leftUp + abs(leftHoriz) + abs(rightHoriz))\n            l_horiz_percent = abs(leftHoriz) / float(leftUp + abs(leftHoriz) + abs(rightHoriz))\n            r_horiz_percent = abs(rightHoriz) / float(leftUp + abs(leftHoriz) + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n         \n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp < 0 and leftHoriz < 0):\n        # Quadrant 3\n\n        if(rightHoriz == 0):\n            #Move Southwest\n            vert_percent = abs(leftUp) / float(abs(leftUp) + abs(leftHoriz))\n            l_horiz_percent = 1.0 - vert_percent\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n        \n        elif(rightHoriz > 0):\n            #Turn right (+-+-) while going Southwest\n            vert_percent = abs(leftUp) / float(abs(leftUp) + abs(leftHoriz) + rightHoriz)\n            l_horiz_percent = abs(leftHoriz) / float(abs(leftUp) + abs(leftHoriz) + rightHoriz)\n            r_horiz_percent = rightHoriz / float(abs(leftUp) + abs(leftHoriz) + rightHoriz)\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        else:\n            #Turn left (-+-+) whlie going Southwest\n            vert_percent = abs(leftUp) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n            l_horiz_percent = abs(leftHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n            r_horiz_percent = abs(rightHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp < 0 and leftHoriz > 0):\n        # Quadrant 4\n\n        if(rightHoriz == 0):\n            #Move Southeast\n            vert_percent = abs(leftUp) / float(abs(leftUp) + leftHoriz)\n            l_horiz_percent = 1.0 - vert_percent\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n        \n        elif(rightHoriz > 0):\n            #Turn right(+-+-) while going Southeast\n            vert_percent = abs(leftUp) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n            l_horiz_percent = abs(leftHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n            r_horiz_percent = abs(rightHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        else:\n            #Turn left (-+-+) while going Southeast\n            vert_percent = abs(leftUp) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n            l_horiz_percent = abs(leftHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n            r_horiz_percent = abs(rightHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp > 0 and leftHoriz == 0):\n       # Forward\n        if(rightHoriz == 0):\n            m1_weight = leftUp\n            m2_weight = leftUp\n            m3_weight = leftUp\n            m4_weight = leftUp\n            \n        #Turn right while going forward\n        elif(rightHoriz > 0):\n            vert_percent = leftUp / float(leftUp + abs(rightHoriz))\n            r_horiz_percent = rightHoriz / float(leftUp + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n        \n        #Turn left while going forward\n        else:\n            vert_percent = leftUp / float(leftUp + abs(rightHoriz))\n            r_horiz_percent = rightHoriz / float(leftUp + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n        \n\n    elif(leftUp < 0 and leftHoriz == 0):\n        #Backwards\n        if(rightHoriz == 0):\n            m1_weight = leftUp\n            m2_weight = leftUp\n            m3_weight = leftUp\n            m4_weight = leftUp\n        \n        #Turn right while going back\n        elif(rightHoriz > 0):\n            vert_percent = abs(leftUp) / float(abs(leftUp) + rightHoriz)\n            r_horiz_percent = rightHoriz / float(abs(leftUp) + rightHoriz)\n\n            m1_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n\n        #Turn left while going back\n        else:\n            vert_percent = abs(leftUp) / float(abs(leftUp) + abs(rightHoriz))\n            r_horiz_percent = abs(rightHoriz) / float(abs(leftUp) + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp == 0 and leftHoriz > 0):\n        #Move right\n        if(rightHoriz == 0):\n            m1_weight = leftHoriz\n            m2_weight = -1 * leftHoriz\n            m3_weight = -1 * leftHoriz\n            m4_weight = leftHoriz\n        \n        #Move right while turning right\n        elif(rightHoriz > 0):\n            l_horiz_percent = leftHoriz / float(leftHoriz + rightHoriz)\n            r_horiz_percent = rightHoriz / float(leftUp + abs(rightHoriz))\n\n            m1_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((l_horiz_percent * -1* leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        #Move right while turning left\n        else:\n            l_horiz_percent = leftHoriz / float(leftHoriz + abs(rightHoriz))\n            r_horiz_percent = rightHoriz / float(leftHoriz + abs(rightHoriz))\n\n            m1_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m2_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m3_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m4_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n\n        \n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp == 0 and leftHoriz < 0):\n        #Move left\n        if(rightHoriz == 0):\n            m1_weight = leftHoriz\n            m2_weight = -1* leftHoriz\n            m3_weight = -1 * leftHoriz\n            m4_weight = leftHoriz\n\n        #Move left while turning right\n        elif(rightHoriz > 0):\n            l_horiz_percent = abs(leftHoriz) / float(abs(leftHoriz) + rightHoriz)\n            r_horiz_percent = rightHoriz / float(abs(leftUp) + abs(rightHoriz))\n\n            m1_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        #Move left while turning left\n        else:\n            l_horiz_percent = abs(leftHoriz) / float(abs(leftHoriz) + abs(rightHoriz))\n            r_horiz_percent = abs(rightHoriz) / float(abs(leftUp) + abs(rightHoriz))\n\n            m1_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent  * rightHoriz))\n            m2_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n    \n    elif(leftUp == 0 and leftHoriz == 0 and rightHoriz > 0):\n        #Turn right\n        motorTL.spin(FORWARD)\n        motorTL.set_velocity(rightHoriz, PERCENT)\n        motorTR.spin(REVERSE)\n        motorTR.set_velocity(-1 * rightHoriz, PERCENT)\n        motorBL.spin(FORWARD)\n        motorBL.set_velocity(rightHoriz, PERCENT)\n        motorBR.spin(REVERSE)\n        motorBR.set_velocity(-1 * rightHoriz, PERCENT)\n\n    elif(leftUp == 0 and leftHoriz == 0 and rightHoriz < 0):\n        #Turn left\n        motorTL.spin(REVERSE)\n        motorTL.set_velocity(rightHoriz, PERCENT)\n        motorTR.spin(FORWARD)\n        motorTR.set_velocity(-1 * rightHoriz, PERCENT)\n        motorBL.spin(REVERSE)\n        motorBL.set_velocity(rightHoriz, PERCENT)\n        motorBR.spin(FORWARD)\n        motorBR.set_velocity(-1 * rightHoriz, PERCENT)\n            \n    else:\n        for motor in motors:\n            motor.stop()\n    \n    \n    #THIS IS REALLY IMPORTANT TO KNOW\n    #button order: l1[0], l2[1], r1[2], r2[3], up[4], right[5], down[6], left[7], x[8], a[9], b[10], y[11]\n\n    #EXAMPLE OF HOW TO SET BUTTON TO MOTOR:\n    # if(button_states[0]):\n    #     m5.spin(FORWARD)\n    #     m5.set_velocity(80, PERCENT)\n    # else:\n    #     m5.stop()\n\n    if(button_states[2] == True):\n        m8.spin(FORWARD)\n        m8.set_velocity(80, PERCENT)\n    elif(button_states[3] == True):\n        m8.spin(REVERSE)\n        m8.set_velocity(-80, PERCENT)\n    else:\n        m8.stop()\n    \n    # EXAMPLE OF HOW TO SET BUTTON TO SOLENOID\n    # sol_a.set(button_states[8])\n\ndef somethingChanged():\n\n    if(leftSpeed != prevLeftState or rightSpeed != prevRightState or lHorizAxisState != prevLHorizAxisState or rHorizAxisState != prevRHorizAxisState or button_states != prev_button_states):\n        return True\n    \n    return False\n\ndef record():\n    global first_record\n    global autonomous_start_offset\n    if(first_record):\n        autonomous_start_offset = int(brain.timer.time(MSEC))\n        first_record = not first_record\n    print(str(leftSpeed) + \"&\" + str(lHorizAxisState) + \"&\" + str(rightSpeed) + \"&\" + str(rHorizAxisState)  + \"&\" + str(int(button_states[0])) + str(int(button_states[1])) + str(int(button_states[2])) + str(int(button_states[3])) + str(int(button_states[4]))\n    + str(int(button_states[5])) + str(int(button_states[6])) + str(int(button_states[7])) + str(int(button_states[8])) + str(int(button_states[9])) + str(int(button_states[10])) + str(int(button_states[11])) + \"@\" + str(int(brain.timer.time(MSEC)) - autonomous_start_offset) + \"|\", end=\"\")\n\n#######################################\ndef pre_autonomous():\n    # actions to do when the program starts\n    wait(1, SECONDS)\n#########################################\ndef autonomous():\n    global button_states\n\n    for i in range(len(button_states)):\n        button_states[i] = False\n\n    startIndex = 0\n    startTime = int(brain.timer.time(MSEC))\n\n    while(startIndex < len(RECORDED_INPUT)):\n        chunk = RECORDED_INPUT[startIndex : RECORDED_INPUT.index(\"|\", startIndex)]\n        #LEFT VERTICAL AXIS\n        andIndex1 = chunk.index(\"&\")\n        a3 = int(chunk[0 : andIndex1])\n\n        #LEFT HORIZONTAL AXIS\n        andIndex2 = chunk.index(\"&\", andIndex1 + 1)\n        a4 = int(chunk[andIndex1 + 1 : andIndex2])\n\n        #RIGHT VERTICAL AXIS\n        andIndex3 = chunk.index(\"&\", andIndex2 + 1)\n        a2 =int(chunk[andIndex2 + 1 : andIndex3])\n\n        #RIGHT HORIZONTAL AXIS\n        andIndex4 = chunk.index(\"&\", andIndex3 + 1)\n        a1 = int(chunk[andIndex3 + 1 : andIndex4])\n\n        l1 = chunk[andIndex4 + 1 : andIndex4 + 2]\n        l2 = chunk[andIndex4 + 2 : andIndex4 + 3]\n        r1 = chunk[andIndex4 + 3 : andIndex4 + 4]\n        r2 = chunk[andIndex4 + 4 : andIndex4 + 5]\n        up = chunk[andIndex4 + 5 : andIndex4 + 6]\n        right = chunk[andIndex4 + 6 : andIndex4 + 7]\n        down = chunk[andIndex4 + 7 : andIndex4 + 8]\n        left = chunk[andIndex4 + 8 : andIndex4 + 9]\n        X = chunk[andIndex4 + 9 : andIndex4 + 10]\n        A = chunk[andIndex4 + 10 : andIndex4 + 11]\n        B = chunk[andIndex4 + 11 : andIndex4 + 12]\n        Y = chunk[andIndex4 + 12 : andIndex4 + 13]\n\n        buttons = [l1, l2, r1, r2, up, right, down, left, X, A, B, Y]\n        \n        atIndex = chunk.index(\"@\")\n        milliseconds = int(chunk[(atIndex + 1) : len(chunk)])\n        \n        startIndex += (len(chunk) + 1)\n\n        while(True):\n            if(milliseconds <= int(brain.timer.time(MSEC) - startTime)):\n                for i in range(len(buttons)):\n                    button_states[i] = bool(int(buttons[i]))\n\n                move(a3, a2, a4, a1)\n                #print(\"L: \" + str(a3) + \" R: \" + str(a2))\n                break\n            \n\n\n##########################################   \n\ndef user_control():\n    global leftSpeed\n    global rightSpeed\n    global recordInput\n    global prevLeftState\n    global prevRightState\n    global lHorizAxisState\n    global rHorizAxisState\n    global prevLHorizAxisState\n    global prevRHorizAxisState\n    global prev_button_states\n    global button_states\n\n    #button order: l1[0], l2[1], r1[2], r2[3], up[4], right[5], down[6], left[7], x[8], a[9], b[10], y[11]\n    while(True):   \n        leftSpeed = controller_1.axis3.position()\n        rightSpeed = controller_1.axis2.position()\n        lHorizAxisState = controller_1.axis4.position()\n        rHorizAxisState = controller_1.axis1.position()\n        \n        if(controller_1.buttonUp.pressing()):\n            recordInput = not(recordInput)\n            if(recordInput):\n                controller_1.screen.print(\"RECORDING\")\n            else:\n                controller_1.screen.clear_row(1)\n                controller_1.screen.set_cursor(1, 1)\n            wait(200, MSEC)\n            \n\n        #MOVE MOTOR WITH SHOULDER BUTTONS\n        if(controller_1.buttonL1.pressing()):\n            button_states[0] = True\n        else:\n            button_states[0] = False\n        \n        if(controller_1.buttonL2.pressing()):\n            button_states[1] = True\n        else:\n            button_states[1] = False\n        \n        if(controller_1.buttonR1.pressing()):\n            button_states[2] = True\n        else:\n            button_states[2] = False\n        \n        if(controller_1.buttonR2.pressing()):\n            button_states[3] = True\n        else:\n            button_states[3] = False\n\n\n        if(somethingChanged()):\n            prevLeftState = leftSpeed\n            prevRightState = rightSpeed\n            prevLHorizAxisState = lHorizAxisState\n            prevRHorizAxisState = rHorizAxisState\n            prev_button_states = button_states.copy()\n\n            move(leftSpeed, rightSpeed, lHorizAxisState, rHorizAxisState)\n            \n            if(recordInput):\n                record()\n\n        wait(20, MSEC)\n\n#########################################\n\n##DISABLE FOR COMPETITION##\ntesting_auton = False\n\nif(testing_auton):\n    autonomous()\nelse:\n    # create competition instance\n    comp = Competition(user_control, autonomous)\n\n#################################\n","textLanguage":"python","rconfig":[{"port":[20],"name":"motorTL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[11],"name":"motorTR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[10],"name":"motorBL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[1],"name":"motorBR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[3],"name":"m5","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[6],"name":"m6","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[7],"name":"m7","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[8],"name":"m8","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[1],"name":"sol_a","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2],"name":"sols","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}